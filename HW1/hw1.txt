1. Since I didn't realize List.mem was actually a function I wrote my own 
is_element function. It iterates through the entire list and sees if any
element equals the first parameter passed in. I used the function by 
checking if every element of a is within set b. 

2. The sets are only equal if they are subsets of each other.

3. If a is empty, the union is simply b. Otherwise, check if the head of
a is in b. If it is continue checking the rest of a's tail. If the head 
isn't in b it adds head to the union list (list b) and continues with the 
tail of a.

4. I recursed through a, a list of lists, by creating 2 escape conditions:
when the list is empty and when there's only one element. I would then
combine the first two characters into a union and concatenate it to the 
end. One problem is that this solution is a bit inefficient as it has n^2
runtime.

5. It's actually impossible to write this function due to the way how the 
paradox works. Let's look at set S of all sets that don't contain themselves. 
If S contains itself then it should not be in the set S but if it doesn't 
contain itself then it should be in the set S but the fact that it is in 
set S is a contradition. Due to this paradox OCaml doesn't allow sets that 
contains themselves.

6. 